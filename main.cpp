// Copyright (c) 2020 University of Florida
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// Greg Stitt
// University of Florida
//
// This example uses the same AFU wrapper class as previous examples, but
// writes to a large number of memory-mapped addresses that the AFU implements
// across both block RAM and registers. For this example, the code uses
// the term control/status register (CSR) for the memory-mapped registers.

#include <cstdlib>
#include <iostream>

#include <opae/utils.h>

#include "AFU.h"

using namespace std;

// Auto-generated by OPAE's afu_json_mgr script
#include "afu_json_info.h"

//=========================================================
// Define the base address of the memory-mapped registers
// (i.e. control/status (CSR) registers) and block RAM that 
// was used in the RTL code.
//
// NOTE: Ideally this could be generated with a .json file just like the
// AFU_ACCEL_UUID. Without auto-generation, you must manually ensure that
// the addresses match between the RTL code and software code.
//=========================================================

// Base MMIO address of the CSRs
//#define CSR_BASE_ADDR 0x0020
// The total number of CSRs
//#define NUM_CSR 16

// Base MMIO address of the block RAM
#define BRAM_BASE_ADDR 0x0020
// Number of 64-bit words in the block RAM
#define BRAM_WORDS 512


int main(int argc, char *argv[]) {

  try {
    // Instantiate the AFU with the corresponding UUID.
    AFU afu(AFU_ACCEL_UUID);
    
    unsigned errors = 0;
  //  uint64_t csr[NUM_CSR];

    // Write a random value to each CSR and save the values in an array 
    // NOTE: in many cases, CSRs are only read by software and written by the
    // FPGA. For example, if some hardware exception occurred in the AFU, the
    // AFU would set a CSR to reflect that. This example writes to all the 
    // register solely for MMIO testing purposes.
//    for (unsigned i=0; i < NUM_CSR; i++) {      
  //    csr[i] = rand();
//
      // The i*2 is needed because each address is for a 32-bit word, and the 
      // AFU only implemented 64-bit words.
      // If this extra operation is confusing, you could potentially create
      // another method in the AFU class (e.g., writeCSR) that does this
      // operation internally. Intel has reference examples that do exactly
      // this. I generally prefer to use the same MMIO addresses in software 
      // that are used in the AFU because when debugging a simulation I don't 
      // have to do any extra translation. For any realistic example, I use an
      // enum or #defines that provide meaningful names to all CSRs, so in that
      // case, the readability is the same in either approach.
    //  afu.write(CSR_BASE_ADDR+i*2, csr[i]);
   // }

    // Read the CSR values back and verify correctness.
   // for (unsigned i=0; i < NUM_CSR; i++) {      
     // uint64_t result = afu.read(CSR_BASE_ADDR+i*2);
     // cout<<"result :"<<result<<endl; 
   //  if (result != csr[i]) {
//	cerr << "ERROR: Read from MMIO register has incorrect value " << result << " instead of " << csr[i] << endl;
//	errors ++;
  //    }
   // }

    // Repeat the same tests but for the block RAM MMIO addresses.

  uint32_t bram[BRAM_WORDS];   
afu.write(0x0020,0xf1402573);
  uint32_t result120 = afu.read(0x0020);

afu.write(0x0022, 0x00050663);
uint32_t result121 = afu.read(0x0022);
 afu.write(0x0024, 0x00100593);
uint32_t result122 = afu.read(0x0024);

afu.write(0x0026, 0x00b50a63);
uint32_t result123 = afu.read(0x0026);
afu.write(0x0028, 0x00500113);
uint32_t result124 = afu.read(0x0028);
afu.write(0x002a, 0x02202823);
uint32_t result125 = afu.read(0x002a);
afu.write(0x002c, 0x3002183);
uint32_t result126 = afu.read(0x002c);

afu.write(0x002e, 0x0140006f);
uint32_t result127 = afu.read(0x002e);
afu.write(0x0030, 0x00500213);
uint32_t result128 = afu.read(0x0030);
afu.write(0x0032, 0x02402c23);
uint32_t result129 = afu.read(0x0032);
afu.write(0x0034, 0x03802283);
uint32_t result130 = afu.read(0x0034);
afu.write(0x0036, 0x0040006f);
uint32_t result131 = afu.read(0x0036);
afu.write(0x0038, 0x0000006f);
uint32_t result132 = afu.read(0x0038);



//uint32_t result123 = afu.read(0x0044);
//uint32_t result124 = afu.read(0x0048);
//uint32_t result125 = afu.read(0x0030);
//uint32_t result126 = afu.read(0x0038);



/*
afu.write(0x0026,0x10000113);
afu.write(0x0028,0x00500113);
afu.write(0x002c,0x10000113);
afu.write(0x0030,0x00500113);
afu.write(0x0034,0x10000113);
afu.write(0x0038,0x00500113);
afu.write(0x003c,0x10000113);
afu.write(0x0040,0x00500113);
afu.write(0x0044,0x10000113);
afu.write(0x0046,0x00500113);
afu.write(0x0048,0x10000113);
afu.write(0x004c,0x00500113);
afu.write(0x0050,0x10000113);
afu.write(0x0054,0x00500113);
afu.write(0x0058,0x10000113);
afu.write(0x005c,0x00500113);
afu.write(0x0060,0x00600413);
*/

/* afu.write(0x0020,0x1);
  uint32_t result120 = afu.read(0x0020);
afu.write(0x0024, 0x2);
afu.write(0x0026,0x3);
afu.write(0x0028,0x4);
afu.write(0x002c,0x5);
afu.write(0x0030,0x6);
afu.write(0x0034,0x7);
afu.write(0x0038,0x8);
afu.write(0x003c,0x9);
afu.write(0x0040,0x10);
afu.write(0x0044,0x11);
afu.write(0x0046,0x12);
afu.write(0x0048,0x13);
afu.write(0x004c,0x14);
afu.write(0x0050,0x15);
afu.write(0x0054,0x16);
afu.write(0x0058,0x17);
afu.write(0x005c,0x18);
afu.write(0x0060,0x19);
//afu.write(0x0064,0x00500113);
//afu.write(0x0026, 0220);
uint32_t result1 = afu.read(0x0024);
//uint32_t result3 = afu.read(0x0022);
uint32_t result11 = afu.read(0x0026);
uint32_t result12 = afu.read(0x0028);
uint32_t result13 = afu.read(0x002c);
uint32_t result14 = afu.read(0x0030);
uint32_t result15 = afu.read(0x0034);
uint32_t result16 = afu.read(0x0038);
uint32_t result17 = afu.read(0x003c);
uint32_t result18 = afu.read(0x0040);
uint32_t result19 = afu.read(0x0044);
uint32_t result20 = afu.read(0x0046);
uint32_t result21 = afu.read(0x0048);
uint32_t result22 = afu.read(0x004c);
uint32_t result23 = afu.read(0x0050);
uint32_t result24 = afu.read(0x0054);
uint32_t result25 = afu.read(0x0058);
uint32_t result26 = afu.read(0x005c);
uint32_t result27 = afu.read(0x0060); */
//uint32_t result28 = afu.read(0x0064);
/*
afu.write(0x0064, 258);
afu.write(0x0100, 259);
afu.write(0x047c, 268);
  uint64_t result121 = afu.read(0x03ee);
 uint64_t result1 = afu.read(0x03f0);
    uint64_t result2 = afu.read(0x41a);
     uint64_t result3 = afu.read(0x041c);
    uint64_t result4 = afu.read(0x041e);
*/

cout<<"result 20="<<result120<<endl;     
cout<<"result 22="<<result121<<endl;
cout<<"result 24="<<result122<<endl;

cout<<"result 26="<<result123<<endl;
cout<<"result 28="<<result124<<endl;
cout<<"result 2a="<<result125<<endl;
cout<<"result 2c="<<result126<<endl;

cout<<"result 2e="<<result127<<endl;
cout<<"result 30="<<result128<<endl;
cout<<"result 32="<<result129<<endl;
cout<<"result 34="<<result130<<endl;
cout<<"result 36="<<result131<<endl;
cout<<"result 38="<<result132<<endl;


/*
cout<<"result 24="<<result1<<endl;
cout<<"result 11="<<result11<<endl;
cout<<"result 12="<<result12<<endl;
cout<<"result 13="<<result13<<endl;
cout<<"result 14="<<result14<<endl;
cout<<"result 15="<<result15<<endl;
cout<<"result 16="<<result16<<endl;
cout<<"result 17="<<result17<<endl;
cout<<"result 18="<<result18<<endl;
cout<<"result 19="<<result19<<endl;
cout<<"result 20="<<result20<<endl;
cout<<"result 21="<<result21<<endl;
cout<<"result 22="<<result22<<endl;
cout<<"result 23="<<result23<<endl;
cout<<"result 24="<<result24<<endl;
cout<<"result 25="<<result25<<endl;
cout<<"result 26="<<result26<<endl;
cout<<"result 27="<<result27<<endl;
*/
//cout<<"result 28="<<result28<<endl;
//cout<<"result 22="<<result3<<endl;
/*    cout<<"result 64="<<result1<<endl;
        cout<<"result 9e="<<result2<<endl;
         cout<<"result 100="<<result3<<endl;
     cout << "result 47e=" <<result4 <<endl;          
*/  

//uint32_t result2 = afu.read(0x0100);
//cout<<"result 256="<<result2<<endl;
  // Write random values to the memory-mapped BRAM.
    for (unsigned i=2; i < BRAM_WORDS; i++) {            
  //    bram[i] = rand();
 // afu.write(BRAM_BASE_ADDR+i*2, bram[i]);
    }

    // Read the BRAM values back and verify correctness.
    for (unsigned i=0; i < BRAM_WORDS; i++) {            
//   cout<<"bram address:"<<(BRAM_BASE_ADDR+i*2)<<endl;
  //   uint64_t result = afu.read(BRAM_BASE_ADDR+i*2);
       //cout<<"bram address:"<<(BRAM_BASE_ADDR+i*2)<<endl;    
//cout<<"result csr:"<<result<<endl;  
  //if (result != bram[i]) {	
//	cerr << "ERROR: Read from MMIO BRAM has incorrect value " << result << " instead of " << bram[i] << endl;
//	errors ++;
  //  }
    }

    if (errors == 0) {
      cout << "All BRAM MMIO tests succeeded." << endl;
      return EXIT_SUCCESS;
    }
    else {
//      cout << "MMIO tests failed." << endl;
      return EXIT_FAILURE;
    }
  }
  // Exception handling for all the runtime errors that can occur within 
  // the AFU wrapper class.
  catch (const fpga_result& e) {    
    
    // Provide more meaningful error messages for each exception.
    if (e == FPGA_BUSY) {
      cerr << "ERROR: All FPGAs busy." << endl;
    }
    else if (e == FPGA_NOT_FOUND) { 
      cerr << "ERROR: FPGA with accelerator " << AFU_ACCEL_UUID 
	   << " not found." << endl;
    }
    else {
      // Print the default error string for the remaining fpga_result types.
      cerr << "ERROR: " << fpgaErrStr(e) << endl;    
    }
  }
  catch (const runtime_error& e) {    
    cerr << e.what() << endl;
  }
  catch (const opae::fpga::types::no_driver& e) {
    cerr << "ERROR: No FPGA driver found." << endl;
  }

  return EXIT_FAILURE;
}
