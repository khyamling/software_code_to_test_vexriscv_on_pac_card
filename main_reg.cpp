// Copyright (c) 2020 University of Florida
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// Greg Stitt
// University of Florida
//
// This example uses the same AFU wrapper class as previous examples, but
// writes to a large number of memory-mapped addresses that the AFU implements
// across both block RAM and registers. For this example, the code uses
// the term control/status register (CSR) for the memory-mapped registers.

#include <cstdlib>
#include <iostream>

#include <opae/utils.h>

#include "AFU.h"

using namespace std;

// Auto-generated by OPAE's afu_json_mgr script
#include "afu_json_info.h"

//=========================================================
// Define the base address of the memory-mapped registers
// (i.e. control/status (CSR) registers) and block RAM that 
// was used in the RTL code.
//
// NOTE: Ideally this could be generated with a .json file just like the
// AFU_ACCEL_UUID. Without auto-generation, you must manually ensure that
// the addresses match between the RTL code and software code.
//=========================================================

// Base MMIO address of the CSRs
#define CSR_BASE_ADDR 0x0020
// The total number of CSRs
#define NUM_CSR 16

// Base MMIO address of the block RAM
#define BRAM_BASE_ADDR 0x0080
// Number of 64-bit words in the block RAM
#define BRAM_WORDS 512


int main(int argc, char *argv[]) {

  try {
    // Instantiate the AFU with the corresponding UUID.
    AFU afu(AFU_ACCEL_UUID);
    
    unsigned errors = 0;
    uint64_t csr[NUM_CSR]; //={39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54};

    // Write a random value to each CSR and save the values in an array 
    // NOTE: in many cases, CSRs are only read by software and written by the
    // FPGA. For example, if some hardware exception occurred in the AFU, the
    // AFU would set a CSR to reflect that. This example writes to all the 
    // register solely for MMIO testing purposes.
//     csr[0]=39;
    // afu.write(0x0020, 39);
   // uint64_t result0 = afu.read(0x0020);
/*      cout <<" result0 : "<< result0 << "CSR0 :"<< 39 <<endl;
       if(result0 ==  39)
{
cout<<"success"<<endl;
}
else
{
cout<<"failed"<<endl;
}*/
/*
 afu.write(0x0022, 40);
uint64_t result1 = afu.read(0x0022); 
afu.write(0x0024, 41);
uint64_t result2 = afu.read(0x0024); 
afu.write(0x0026, 42);
uint64_t result3 = afu.read(0x0026); 
afu.write(0x0028, 43);
uint64_t result4 = afu.read(0x0028); 
afu.write(0x002a, 44);
uint64_t result5 = afu.read(0x002a); 
afu.write(0x002c, 45);
uint64_t result6 = afu.read(0x002c); 
afu.write(0x002e, 46);
uint64_t result7 = afu.read(0x002e); 
afu.write(0x0030, 47);
uint64_t result8 = afu.read(0x0030); 
afu.write(0x0032, 48);
uint64_t result9 = afu.read(0x0032); 
afu.write(0x0034, 49);
uint64_t result10 = afu.read(0x0034); 
afu.write(0x0036, 50);
uint64_t result11 = afu.read(0x0036); 
afu.write(0x0038, 51);
uint64_t result12 = afu.read(0x0038); 
afu.write(0x003a, 52);
uint64_t result13 = afu.read(0x003a); 
afu.write(0x003c, 53);
uint64_t result14 = afu.read(0x003c); 
afu.write(0x003e, 54);
uint64_t result15 = afu.read(0x003e); 

cout << "result0:" <<result0 <<endl
     << "result1:" <<result1 <<endl
    << "result2:" <<result2 <<endl
   << "result3:" <<result3 <<endl
   << "result4:" <<result4 <<endl
   << "result5:" <<result5 <<endl
  << "result6: "<<result6 <<endl
     << "result7:" <<result7 <<endl
    << "result8: "<<result8 <<endl
   << "result9: "<<result9 <<endl
   << "result10: "<<result10 <<endl
   << "result11: "<<result11 <<endl
    << "result12:" <<result12 <<endl
   << "result13:" <<result13 <<endl
   << "result14:" <<result14 <<endl
   << "result15:" <<result15 <<endl;

*/ 
  /* uint64_t result1 = afu.read(0x0022);
      cout <<" result1 : "<< result1 << "CSR1 :"<< csr[1] <<endl;
       if(result1 ==  csr[1])
{
cout<<"success"<<endl;
}
else
{
cout<<"failed"<<endl;
}*/


    for (unsigned i=0; i < NUM_CSR; i++) {      
      csr[i] = rand();

      // The i*2 is needed because each address is for a 32-bit word, and the 
      // AFU only implemented 64-bit words.
      // If this extra operation is confusing, you could potentially create
      // another method in the AFU class (e.g., writeCSR) that does this
      // operation internally. Intel has reference examples that do exactly
      // this. I generally prefer to use the same MMIO addresses in software 
      // that are used in the AFU because when debugging a simulation I don't 
      // have to do any extra translation. For any realistic example, I use an
      // enum or #defines that provide meaningful names to all CSRs, so in that
      // case, the readability is the same in either approach.
      afu.write(CSR_BASE_ADDR+i*2, csr[i]);
    }

    // Read the CSR values back and verify correctness.
      uint64_t result1 = afu.read(0x0024);
      uint64_t result2 = afu.read(0x0026);
     uint64_t result3 = result1+result2;
        cout<< "result3 :"<<result3<<endl;
    for (unsigned i=0; i < NUM_CSR; i++) {      
      uint64_t result = afu.read(CSR_BASE_ADDR+i*2);
   cout << "result csr :" << result <<endl;
      if (result != csr[i]) {
	cerr << "ERROR: Read from MMIO register has incorrect value " << result << " instead of " << csr[i] << endl;
	errors ++;
      }
    }

    // Repeat the same tests but for the block RAM MMIO addresses.

//    uint64_t bram[BRAM_WORDS];   
    // Write random values to the memory-mapped BRAM.
  //  for (unsigned i=0; i < BRAM_WORDS; i++) {            
     // bram[i] = rand();
    //  afu.write(BRAM_BASE_ADDR+i*2, bram[i]);
//    }

    // Read the BRAM values back and verify correctness.
  //  for (unsigned i=0; i < BRAM_WORDS; i++) {            
  //    uint64_t result = afu.read(BRAM_BASE_ADDR+i*2);
//cout<<"result BRAM :"<<result<<endl;     
 //uint64_t result1 = afu.read(0x0086);
//cout << " result1 BRAM :"<< result1 <<endl;
 //if (result != bram[i]) {	
//	cerr << "ERROR: Read from MMIO BRAM has incorrect value " << result << " instead of " << csr[i] << endl;
//	errors ++;
    //  }
  //  }

    if (errors == 0) {
      cout << "All register MMIO tests succeeded." << endl;
      return EXIT_SUCCESS;
    }
    else {
      cout << "MMIO tests failed." << endl;
      return EXIT_FAILURE;
    }
  }
  // Exception handling for all the runtime errors that can occur within 
  // the AFU wrapper class.
  catch (const fpga_result& e) {    
    
    // Provide more meaningful error messages for each exception.
    if (e == FPGA_BUSY) {
      cerr << "ERROR: All FPGAs busy." << endl;
    }
    else if (e == FPGA_NOT_FOUND) { 
      cerr << "ERROR: FPGA with accelerator " << AFU_ACCEL_UUID 
	   << " not found." << endl;
    }
    else {
      // Print the default error string for the remaining fpga_result types.
      cerr << "ERROR: " << fpgaErrStr(e) << endl;    
    }
  }
  catch (const runtime_error& e) {    
    cerr << e.what() << endl;
  }
  catch (const opae::fpga::types::no_driver& e) {
    cerr << "ERROR: No FPGA driver found." << endl;
  }

  return EXIT_FAILURE;
}
